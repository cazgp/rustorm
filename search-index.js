var searchIndex = {};
searchIndex["rustorm"] = {"doc":"Rustorm is a simple ORM implemented in rust.","items":[[0,"query","rustorm","",null,null],[3,"Range","rustorm::query","",null,null],[12,"limit","","",0,null],[12,"offset","","",0,null],[3,"Query","","",null,null],[12,"sql_type","","sql type determine which type of query to form, some fields are not applicable to other types of query",1,null],[12,"distinct","","whether to select the records distinct",1,null],[12,"enumerate_all","","whether to enumate all columns in involved models",1,null],[12,"declared_query","","",1,null],[12,"enumerated_fields","","fields can be functions, column sql query, and even columns",1,null],[12,"distinct_on_columns","","specify to use distinct ON set of columns",1,null],[12,"from","","where the focus of values of column selection\nthis is the table to insert to, update to delete, create, drop\nwhe used in select, this is the\npub from_table:Option&lt;TableName&gt;,\nfrom field, where field can be a query, table, or function",1,null],[12,"joins","","joining multiple tables",1,null],[12,"filters","","filter records, ~ where statement of the query",1,null],[12,"order_by","","ordering of the records via the columns specified",1,null],[12,"group_by","","grouping columns to create an aggregate",1,null],[12,"having","","having field,",1,null],[12,"excluded_columns","","exclude the mention of the columns in the SQL query, useful when ignoring changes in update/insert records",1,null],[12,"range","","caters both limit-&gt;offset and page-&gt;page_size\nsetting page and page_size can not interchange the order",1,null],[12,"values","","The data values, used in bulk inserting, updating,",1,null],[12,"enumerated_returns","","the returning clause of the query when supported,",1,null],[4,"SqlType","","Could have been SqlAction",null,null],[13,"SELECT","","",2,null],[13,"INSERT","","",2,null],[13,"UPDATE","","",2,null],[13,"DELETE","","",2,null],[4,"Error","","Query Error",null,null],[13,"NoTableSpecified","","",3,null],[13,"NoColumnSpecified","","",3,null],[13,"SqlError","","",3,null],[0,"column_name","","",null,null],[3,"ColumnName","rustorm::query::column_name","",null,null],[12,"column","","",4,null],[12,"table","","",4,null],[12,"schema","","",4,null],[8,"ToColumnName","","",null,null],[10,"to_column_name","","",5,null],[11,"clone","","",4,null],[11,"fmt","","",4,null],[11,"decode","","",4,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",4,null],[11,"from_str","","",4,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"default_rename","","",4,null],[11,"complete_name","","table name and column name",4,null],[11,"super_complete_name","","includes the schema, table name and column name",4,null],[11,"is_conflicted","","is this column conflicts the other column\nconflicts means, when used both in a SQL query, it will result to ambiguous columns",4,null],[11,"fmt","","",4,null],[11,"eq","","",4,null],[11,"ne","","",4,null],[0,"table_name","rustorm::query","",null,null],[3,"TableName","rustorm::query::table_name","",null,null],[12,"schema","","",6,null],[12,"name","","",6,null],[12,"columns","","optional columns needed when rename for conflicting columns are needed",6,null],[8,"ToTableName","","convert str, IsTable to TableName",null,null],[10,"to_table_name","","",7,null],[11,"clone","","",6,null],[11,"fmt","","",6,null],[11,"default","","",6,{"inputs":[],"output":{"name":"tablename"}}],[11,"from_str","","",6,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"complete_name","","",6,null],[11,"eq","","",6,null],[11,"ne","","",6,null],[11,"fmt","","",6,null],[0,"filter","rustorm::query","",null,null],[3,"Condition","rustorm::query::filter","expression has left operand,\nequality and right operand",null,null],[12,"left","","",8,null],[12,"equality","","",8,null],[12,"right","","",8,null],[3,"Filter","","",null,null],[12,"connector","","",9,null],[12,"condition","","",9,null],[12,"sub_filters","","",9,null],[4,"Connector","","",null,null],[13,"And","","",10,null],[13,"Or","","",10,null],[4,"Equality","","",null,null],[13,"EQ","","",11,null],[13,"NEQ","","",11,null],[13,"LT","","",11,null],[13,"LTE","","",11,null],[13,"GT","","",11,null],[13,"GTE","","",11,null],[13,"IN","","",11,null],[13,"NOT_IN","","",11,null],[13,"LIKE","","",11,null],[13,"ILIKE","","",11,null],[13,"IS_NOT_NULL","","",11,null],[13,"IS_NULL","","",11,null],[8,"HasEquality","","",null,null],[10,"EQ","","",12,null],[10,"NEQ","","",12,null],[10,"GT","","",12,null],[10,"GTE","","",12,null],[10,"LT","","",12,null],[10,"LTE","","",12,null],[10,"LIKE","","",12,null],[10,"ILIKE","","",12,null],[10,"IS_NULL","","",12,null],[10,"IS_NOT_NULL","","",12,null],[10,"IN","","",12,null],[10,"NOT_IN","","",12,null],[11,"fmt","","",8,null],[11,"clone","","",8,null],[11,"fmt","","",10,null],[11,"clone","","",10,null],[11,"fmt","","",11,null],[11,"clone","","",11,null],[11,"fmt","","",9,null],[11,"clone","","",9,null],[11,"new","","user friendly, commonly use API",9,{"inputs":[{"name":"str"},{"name":"equality"},{"name":"tovalue"}],"output":{"name":"self"}}],[11,"AND","","",9,null],[11,"OR","","",9,null],[0,"builder","rustorm::query","",null,null],[3,"QueryBuilder","rustorm::query::builder","",null,null],[5,"SELECT_ALL","","",null,{"inputs":[],"output":{"name":"querybuilder"}}],[5,"SELECT","","",null,{"inputs":[],"output":{"name":"querybuilder"}}],[5,"INSERT","","",null,{"inputs":[],"output":{"name":"querybuilder"}}],[5,"UPDATE","","",null,{"inputs":[{"name":"totablename"}],"output":{"name":"querybuilder"}}],[5,"DELETE","","",null,{"inputs":[],"output":{"name":"querybuilder"}}],[11,"WITH","","if the database support CTE declareted query i.e WITH,\nthen this query will be declared\nif database doesn&#39;t support WITH queries, then this query will be\nwrapped in the from_query\nbuild a builder for this",13,null],[11,"SELECT","","",13,{"inputs":[],"output":{"name":"self"}}],[11,"SELECT_ALL","","",13,{"inputs":[],"output":{"name":"self"}}],[11,"INSERT","","",13,{"inputs":[],"output":{"name":"self"}}],[11,"UPDATE","","",13,{"inputs":[{"name":"totablename"}],"output":{"name":"self"}}],[11,"DELETE","","",13,{"inputs":[],"output":{"name":"self"}}],[11,"DISTINCT","","add DISTINCT ie: SELECT DISTINCT",13,null],[11,"ALL","","",13,null],[11,"SET","","",13,null],[11,"COLUMNS","","",13,null],[11,"VALUES","","",13,null],[11,"FROM","","A more terse way to write the query\nonly 1 table is supported yet",13,null],[11,"INTO","","`into` is used in rust, os settled with `into_`",13,null],[11,"TABLE","","can be used in behalf of into_, from,",13,null],[11,"JOIN","","join a table on this query",13,null],[11,"LEFT_JOIN","","join a table on this query",13,null],[11,"RIGHT_JOIN","","",13,null],[11,"FULL_JOIN","","",13,null],[11,"INNER_JOIN","","",13,null],[11,"WHERE","","",13,null],[11,"GROUP_BY","","",13,null],[11,"HAVING","","",13,null],[11,"ORDER_BY","","",13,null],[11,"LIMIT","","",13,null],[11,"OFFSET","","",13,null],[11,"build","","build the query only, not executed, useful when debugging",13,null],[11,"collect_one","","",13,null],[11,"collect","","",13,null],[0,"function","rustorm::query","",null,null],[3,"Function","rustorm::query::function","function in a sql statement",null,null],[12,"function","","",14,null],[12,"params","","",14,null],[5,"COUNT","","A database function COUNT",null,{"inputs":[{"name":"tooperand"}],"output":{"name":"operand"}}],[5,"MAX","","database function MAX",null,{"inputs":[{"name":"tooperand"}],"output":{"name":"operand"}}],[5,"MIN","","database function MIN",null,{"inputs":[{"name":"tooperand"}],"output":{"name":"operand"}}],[5,"NOW","","A database date function which returns the time\nwhen the query is executed",null,{"inputs":[],"output":{"name":"operand"}}],[11,"fmt","","",14,null],[11,"clone","","",14,null],[0,"join","rustorm::query","",null,null],[3,"Join","rustorm::query::join","",null,null],[12,"modifier","","",15,null],[12,"join_type","","",15,null],[12,"table_name","","",15,null],[12,"on","","",15,null],[4,"JoinType","","",null,null],[13,"CROSS","","",16,null],[13,"INNER","","",16,null],[13,"OUTER","","",16,null],[13,"NATURAL","","",16,null],[4,"Modifier","","",null,null],[13,"LEFT","","",17,null],[13,"RIGHT","","",17,null],[13,"FULL","","",17,null],[8,"ToJoin","","",null,null],[10,"ON","","",18,null],[11,"fmt","","",16,null],[11,"clone","","",16,null],[11,"fmt","","",17,null],[11,"clone","","",17,null],[11,"fmt","","",15,null],[11,"clone","","",15,null],[0,"operand","rustorm::query","",null,null],[4,"Operand","rustorm::query::operand","Operands can be columns, values, and query sources such as tables, functions, and other queries",null,null],[13,"ColumnName","","",19,null],[13,"QuerySource","","",19,null],[13,"Value","","",19,null],[13,"Vec","","",19,null],[13,"None","","",19,null],[8,"ToOperand","","",null,null],[10,"to_operand","","",20,null],[11,"fmt","","",19,null],[11,"clone","","",19,null],[11,"to_operand","","",19,null],[11,"to_operand","collections::string","",21,null],[11,"to_operand","rustc_serialize::json","",22,null],[11,"to_operand","collections::vec","",23,null],[11,"to_operand","uuid","",24,null],[11,"to_operand","chrono::datetime","",25,null],[11,"to_operand","chrono::naive::date","",26,null],[11,"to_operand","chrono::naive::time","",27,null],[11,"to_operand","chrono::naive::datetime","",28,null],[0,"order","rustorm::query","",null,null],[3,"Order","rustorm::query::order","",null,null],[12,"operand","","",29,null],[12,"direction","","",29,null],[12,"nulls_where","","",29,null],[4,"Direction","","",null,null],[13,"ASC","","",30,null],[13,"DESC","","",30,null],[4,"NullsWhere","","",null,null],[13,"FIRST","","",31,null],[13,"LAST","","",31,null],[8,"ToOrder","","",null,null],[10,"to_order","","",32,null],[8,"HasDirection","","",null,null],[10,"ASC","","",33,null],[10,"DESC","","",33,null],[10,"ASC_NULLS_FIRST","","",33,null],[10,"ASC_NULLS_LAST","","",33,null],[10,"DESC_NULLS_FIRST","","",33,null],[10,"DESC_NULLS_LAST","","",33,null],[11,"fmt","","",30,null],[11,"clone","","",30,null],[11,"fmt","","",31,null],[11,"clone","","",31,null],[11,"fmt","","",29,null],[11,"clone","","",29,null],[11,"NULLS_FIRST","","",29,null],[11,"NULLS_LAST","","",29,null],[0,"field","rustorm::query","",null,null],[3,"Field","rustorm::query::field","",null,null],[12,"operand","","the field",34,null],[12,"name","","when renamed as field",34,null],[8,"ToField","","",null,null],[10,"to_field","","",35,null],[8,"Rename","","",null,null],[10,"AS","","",36,null],[11,"fmt","","",34,null],[11,"clone","","",34,null],[11,"rename","","",34,null],[11,"to_field","","",34,null],[0,"source","rustorm::query","",null,null],[3,"SourceField","rustorm::query::source","QuerySource fields can be renamed",null,null],[12,"source","","",37,null],[12,"rename","","",37,null],[4,"QuerySource","","This fields can be used in the FROM field",null,null],[13,"TableName","","",38,null],[13,"Query","","",38,null],[13,"Function","","",38,null],[8,"ToSourceField","","",null,null],[10,"to_source_field","","",39,null],[11,"fmt","","",38,null],[11,"clone","","",38,null],[11,"fmt","","",37,null],[11,"clone","","",37,null],[11,"to_source_field","collections::string","",21,null],[11,"to_source_field","rustorm::query::source","",38,null],[11,"fmt","rustorm::query","",2,null],[11,"clone","","",2,null],[11,"eq","","",2,null],[11,"fmt","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"default","","",0,{"inputs":[],"output":{"name":"range"}}],[11,"clone","","",0,null],[11,"new","","",0,{"inputs":[],"output":{"name":"self"}}],[11,"set_limit","","",0,null],[11,"set_offset","","",0,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"new","","the default query is select",1,{"inputs":[],"output":{"name":"self"}}],[11,"select","","",1,{"inputs":[],"output":{"name":"self"}}],[11,"insert","","",1,{"inputs":[],"output":{"name":"self"}}],[11,"update","","",1,{"inputs":[],"output":{"name":"self"}}],[11,"delete","","",1,{"inputs":[],"output":{"name":"self"}}],[11,"enumerate_all","","",1,null],[11,"all","","",1,null],[11,"select_all","","",1,{"inputs":[],"output":{"name":"self"}}],[11,"column","","all enumerated columns shall be called from this\nany conflict of columns from some other table will be automatically renamed\ncolumns that are not conflicts from some other table,\nbut is the other conflicting column is not explicityly enumerated will not be renamed",1,null],[11,"columns","","",1,null],[11,"exclude_column","","exclude columns when inserting/updating data\nalso ignores the column when selecting records\nuseful for manipulating thin records by excluding huge binary blobs such as images",1,null],[11,"exclude_columns","","",1,null],[11,"distinct_on_columns","","",1,null],[11,"value","","",1,null],[11,"set","","set a value of a column when inserting/updating records",1,null],[11,"set_limit","","",1,null],[11,"set_offset","","",1,null],[11,"get_range","","",1,null],[11,"only_from","","enumerate only the columns that is coming from this table\nthis will invalidate enumerate_all",1,null],[11,"from_query","","a query to query from\nuse WITH (query) t1 SELECT from t1 declaration in postgresql, sqlite\nuse SELECT FROM (query) in oracle, mysql, others\nalias of the table",1,null],[11,"from","","",1,null],[11,"table","","",1,null],[11,"get_from_table","","returns the first table in the from clause",1,null],[11,"get_involved_tables","","",1,null],[11,"finalize","","preprocess the missing fields of the query,\nsuch as mentioning the columns of the from_table\nenumerate the columns of the involved tables\nskipping those which are explicitly ignored\nthe query will then be built and ready to be executed\nif no enumerated fields and no excluded columns\ndo a select all",1,null],[11,"enumerate_from_table","","",1,null],[11,"get_renamed_columns","","return the list of renamed columns, used in dao conversion to struc types",1,null],[11,"get_enumerated_columns","","return the list of enumerated columns\nwill be used for updating records",1,null],[11,"add_filter","","",1,null],[11,"add_filters","","",1,null],[11,"filter_eq","","column = value",1,null],[11,"filter_lt","","column &lt; value",1,null],[11,"filter_lte","","column &lt;= value",1,null],[11,"filter_gt","","column &gt; value",1,null],[11,"filter_gte","","column &lt;= value",1,null],[11,"return_all","","",1,null],[11,"returns","","",1,null],[11,"enumerate_column_as_return","","",1,null],[11,"build","","build the query only, not executed, useful when debugging",1,null],[11,"debug_build","","Warning: don&#39;t use this in production",1,null],[11,"retrieve","","retrieve a generic types, type is unknown at runtime\nexpects a return, such as select, insert/update with returning clause",1,null],[11,"retrieve_one","","expects a return, such as select, insert/update with returning clause\nno casting of data to structs is done\nThis is used when retrieving multiple models in 1 query, then casting the records to its equivalent structs",1,null],[11,"execute","","delete, update without caring for the return",1,null],[11,"collect","","execute the query, then convert the result",1,null],[11,"collect_one","","execute the query then collect only 1 record",1,null],[0,"dao","rustorm","",null,null],[3,"DaoResult","rustorm::dao","meta result of a query useful when doing complex query, and also with paging\nTODO: good name: DaoRows",null,null],[12,"dao","","",40,null],[12,"renamed_columns","","renamed columns for each table\nie. product =&gt; [(name, product_name),..];",40,null],[12,"total","","the total number of records",40,null],[12,"page","","page of the query",40,null],[12,"page_size","","page size",40,null],[4,"Type","","supported generic datatypes for an ORM",null,null],[13,"Bool","","",41,null],[13,"I8","","",41,null],[13,"I16","","",41,null],[13,"I32","","",41,null],[13,"I64","","",41,null],[13,"U8","","",41,null],[13,"U16","","",41,null],[13,"U32","","",41,null],[13,"U64","","",41,null],[13,"F32","","",41,null],[13,"F64","","",41,null],[13,"String","","",41,null],[13,"VecU8","","",41,null],[13,"Json","","",41,null],[13,"Uuid","","",41,null],[13,"DateTime","","",41,null],[13,"NaiveDate","","",41,null],[13,"NaiveTime","","",41,null],[13,"NaiveDateTime","","",41,null],[4,"Value","","supported generic datatypes for an ORM",null,null],[13,"Bool","","",42,null],[13,"I8","","",42,null],[13,"I16","","",42,null],[13,"I32","","",42,null],[13,"I64","","",42,null],[13,"U8","","",42,null],[13,"U16","","",42,null],[13,"U32","","",42,null],[13,"U64","","",42,null],[13,"F32","","",42,null],[13,"F64","","",42,null],[13,"String","","",42,null],[13,"VecU8","","",42,null],[13,"Json","","",42,null],[13,"Uuid","","",42,null],[13,"DateTime","","",42,null],[13,"NaiveDate","","",42,null],[13,"NaiveTime","","",42,null],[13,"NaiveDateTime","","",42,null],[6,"Dao","","TODO: optimization, used enum types for the key values\nThis will save allocation of string to enum keys which is a few bytes, int",null,null],[6,"ParseError","","",null,null],[8,"IsDao","","trait for converting dao to model\nsized and clonable",null,null],[10,"from_dao","","convert dao to an instance of the corresponding struct of the model\ntaking into considerating the renamed columns",43,{"inputs":[{"name":"dao"}],"output":{"name":"self"}}],[10,"to_dao","","convert from an instance of the struct to a dao representation\nto be saved into the database",43,null],[8,"ToCompact","","Ignore Column are columns that are redundant when displaying as API results",null,null],[10,"redundant_fields","","list of redundant fields that will be removed when doing a compact serialization",44,null],[10,"compact_map","","compact BTreeMap represetation",44,null],[10,"compact_dao","","compact dao representation",44,null],[10,"compact_json","","compact dao representation",44,null],[8,"ToValue","","rename to ToValue",null,null],[10,"to_db_type","","",45,null],[8,"FromValue","","",null,null],[10,"from_type","","",46,{"inputs":[{"name":"value"}],"output":{"name":"self"}}],[11,"fmt","","",41,null],[11,"clone","","",41,null],[11,"eq","","",41,null],[11,"encode","","",41,null],[11,"to_str_repr","","get the string representation when used in rust code",41,null],[11,"fmt","","",42,null],[11,"clone","","",42,null],[11,"eq","","",42,null],[11,"ne","","",42,null],[11,"get_type","","",42,null],[11,"encode","","",42,null],[11,"decode","","",42,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"fmt","","",42,null],[11,"clone","","",40,null],[11,"fmt","","",40,null],[11,"encode","","",40,null],[11,"decode","","",40,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"cast","","cast the dao to the specific struct instance\ndo not include if non nullable parts contains null",40,null],[11,"cast_one","","FIXME: should return an error when there are more than 1 to be casted",40,null],[11,"to_db_type","","",42,null],[11,"to_db_type","collections::string","",21,null],[11,"to_db_type","uuid","",24,null],[11,"to_db_type","chrono::datetime","",25,null],[11,"to_db_type","chrono::naive::date","",26,null],[11,"to_db_type","chrono::naive::time","",27,null],[11,"to_db_type","chrono::naive::datetime","",28,null],[11,"to_db_type","rustc_serialize::json","",22,null],[11,"from_type","collections::string","",21,{"inputs":[{"name":"value"}],"output":{"name":"self"}}],[11,"from_type","uuid","",24,{"inputs":[{"name":"value"}],"output":{"name":"self"}}],[11,"from_type","chrono::datetime","",25,{"inputs":[{"name":"value"}],"output":{"name":"self"}}],[11,"from_type","chrono::naive::time","",27,{"inputs":[{"name":"value"}],"output":{"name":"self"}}],[11,"from_type","chrono::naive::date","",26,{"inputs":[{"name":"value"}],"output":{"name":"self"}}],[11,"from_type","chrono::naive::datetime","",28,{"inputs":[{"name":"value"}],"output":{"name":"self"}}],[11,"from_type","rustc_serialize::json","",22,{"inputs":[{"name":"value"}],"output":{"name":"self"}}],[0,"database","rustorm","",null,null],[4,"SqlOption","rustorm::database","SqlOption, contains the info about the features and quirks of underlying database",null,null],[13,"UsesNumberedParam","","use the numbered parameters, as the case with rust-postgres",47,null],[13,"UsesQuestionMark","","sqlite, jdbc",47,null],[13,"SupportsReturningClause","","postgresql supports returning clause on insert and update",47,null],[13,"SupportsCTE","","support CTE (common table expression ie. WITH) (postgresql, sqlite)",47,null],[13,"SupportsInheritance","","supports inheritance (postgresql)",47,null],[13,"UsesSchema","","whether the database uses schema (postgresl, oracle)",47,null],[13,"ReturnMetaColumns","","wheter the returned rows in a query included Meta columns for easy extraction of records\n(postgres returns this), sqlite does not return meta columns, so you have to extract it by index yourself.",47,null],[4,"BuildMode","","specifies if the sql will be build in debug mode for debugging purposed",null,null],[13,"Debug","","build in debug mode",48,null],[13,"Standard","","build in standard mode",48,null],[4,"DbError","","",null,null],[13,"Error","","",49,null],[13,"PoolError","","",49,null],[13,"PlatformError","","",49,null],[8,"Database","","Generic Database interface\nThis is the database interface which will should be implemented to you the specifics of each database platform\nAt least all methods on this trait should be implemented for target deployment database\nA lower level API for manipulating objects in the database",null,null],[10,"version","","return the version of the database\nlower version of database has fewer supported features",50,null],[10,"begin","","begin database transaction",50,null],[10,"commit","","commit database transaction",50,null],[10,"rollback","","rollback data changes executed prior to calling the begin method",50,null],[10,"is_transacted","","determine if this transaction has been committed or rolledback",50,null],[10,"is_closed","","determine if the database connection closed",50,null],[10,"is_connected","","check if the database is still connected",50,null],[10,"close","","close the database connection",50,null],[10,"is_valid","","determine if the database connection is still valid",50,null],[10,"reset","","reset the database connection",50,null],[11,"select","","select\nreturns an array to the qualified records",50,null],[11,"insert","","insert\ninsert an object, returns the inserted Dao value\nincluding the value generated via the defaults",50,null],[10,"update","","update\nreturns the updated Dao",50,null],[10,"delete","","delete records\nreturns the number of deleted records",50,null],[11,"execute_with_return","","execute query with return dao,\nuse the enumerated column for data extraction when db doesn&#39;t support returning the records column names",50,null],[11,"execute_with_one_return","","execute query with 1 return dao",50,null],[11,"execute","","execute query with no return dao",50,null],[10,"execute_sql_with_return","","execute insert with returning clause, update with returning clause",50,null],[11,"execute_sql_with_one_return","","",50,null],[10,"execute_sql","","everything else, no required return other than error or affected number of records",50,null],[11,"build_query","","build a query, return the sql string and the parameters.\nuse by select to build the select query\nbuild all types of query\nTODO: need to supply the number of parameters where to start the numbering of the number parameters",50,null],[11,"build_operand","","build operand, i.e: columns, query, function, values",50,null],[11,"build_condition","","",50,null],[11,"build_field","","",50,null],[11,"build_query_source","","",50,null],[11,"build_source_field","","",50,null],[11,"build_filter","","",50,null],[11,"build_filters","","build the filter clause or the where clause of the query\nTODO: add the sub filters",50,null],[11,"build_enumerated_fields","","build the enumerated, distinct, *, columns",50,null],[11,"build_select","","build the select statment from the query object",50,null],[11,"build_insert","","TODO: when the number of values is greater than the number of columns\nwrap it into another set and make sure the values are in multiples of the the n columns\nhttp://www.postgresql.org/docs/9.0/static/dml-insert.html",50,null],[11,"build_update","","",50,null],[11,"build_delete","","",50,null],[10,"sql_options","","",50,null],[8,"DatabaseDDL","","Deployment Database should implement this trait,\nto enable automated installation of the app, regardless what database platform\nthe app is developed from.",null,null],[10,"create_schema","","The following methods involves DDL(Data definition language) operation\ncreate a database schema",51,null],[10,"drop_schema","","drop the database schema",51,null],[10,"create_table","","create a database table based on the Model Definition",51,null],[10,"build_create_table","","build sql for create table",51,null],[10,"rename_table","","rename table, in the same schema",51,null],[10,"drop_table","","drop table",51,null],[10,"set_foreign_constraint","","set the foreign key constraint of a table",51,null],[10,"set_primary_constraint","","set the primary key constraint of a table",51,null],[8,"DatabaseDev","","implement this for database that you use as your development platform, to extract meta data information\nabout the tables and their relationship to each other",null,null],[10,"get_table_sub_class","","Database interface use for the development process\napplicable to later version of postgresql where there is inheritance",52,null],[10,"get_parent_table","","",52,null],[10,"get_row_count_estimate","","",52,null],[10,"get_table_metadata","","Build the Table object based on the extracted meta data info from database\nThis is queries directly from the database, so this will be costly. Only used this on initialization processes",52,null],[10,"get_all_tables","","get all the tables in this database (schema, table, is_view)",52,null],[10,"get_inherited_columns","","get the inherited columns of this table",52,null],[10,"dbtype_to_rust_type","","get the equivalent postgresql database data type to rust data type\nreturns (module, type)",52,null],[10,"rust_type_to_dbtype","","",52,null],[11,"eq","","",47,null],[11,"eq","","",48,null],[11,"clone","","",48,null],[11,"fmt","","",49,null],[11,"new","","",49,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"description","","",49,null],[11,"cause","","",49,null],[11,"fmt","","",49,null],[11,"from","","",49,{"inputs":[{"name":"initializationerror"}],"output":{"name":"self"}}],[11,"from","","",49,{"inputs":[{"name":"platformerror"}],"output":{"name":"self"}}],[11,"from","","",49,{"inputs":[{"name":"regexerror"}],"output":{"name":"self"}}],[11,"from","","",49,{"inputs":[{"name":"pgerror"}],"output":{"name":"self"}}],[11,"from","","",49,{"inputs":[{"name":"pgconnecterror"}],"output":{"name":"self"}}],[0,"platform","rustorm","",null,null],[4,"PlatformError","rustorm::platform","",null,null],[13,"PostgresError","","",53,null],[13,"PostgresConnectError","","",53,null],[0,"postgres","","",null,null],[3,"Postgres","rustorm::platform::postgres","",null,null],[12,"pool","","a connection pool is provided",54,null],[11,"new","","create an instance, but without a connection yet,\nuseful when just building sql queries specific to this platform\ninexpensive operation, so can have multiple instances",54,{"inputs":[],"output":{"name":"self"}}],[11,"with_pooled_connection","","",54,{"inputs":[{"name":"pooledconnection"}],"output":{"name":"self"}}],[11,"get_connection","","",54,null],[11,"version","","",54,null],[11,"begin","","",54,null],[11,"commit","","",54,null],[11,"rollback","","",54,null],[11,"is_transacted","","",54,null],[11,"is_closed","","",54,null],[11,"is_connected","","",54,null],[11,"close","","",54,null],[11,"is_valid","","",54,null],[11,"reset","","",54,null],[11,"sql_options","","return this list of options, supported features in the database\nTODO: make this features version specific\nhttp://www.postgresql.org/about/featurematrix/\nwriter CTE  &gt;= 9.1\nInheritance  &gt;= 9.0\nJSON &gt;= 9.2\nJSONB &gt;= 9.4\nReturning &gt;= 8.2",54,null],[11,"update","","",54,null],[11,"delete","","",54,null],[11,"execute_sql_with_return","","",54,null],[11,"execute_sql","","generic execute sql which returns not much information,\nreturns only the number of affected records or errors\ncan be used with DDL operations (CREATE, DELETE, ALTER, DROP)",54,null],[11,"create_schema","","",54,null],[11,"drop_schema","","",54,null],[11,"create_table","","",54,null],[11,"build_create_table","","",54,null],[11,"rename_table","","",54,null],[11,"drop_table","","",54,null],[11,"set_foreign_constraint","","",54,null],[11,"set_primary_constraint","","",54,null],[11,"get_parent_table","","",54,null],[11,"get_row_count_estimate","","https://wiki.postgresql.org/wiki/Count_estimate\nSELECT reltuples::BIGINT AS estimate FROM pg_class WHERE relname=&#39;schema_name.tbl&#39;;",54,null],[11,"get_table_sub_class","","",54,null],[11,"get_table_metadata","","",54,null],[11,"get_all_tables","","",54,null],[11,"get_inherited_columns","","",54,null],[11,"dbtype_to_rust_type","","get the rust data type names from database data type names\nwill be used in source code generation",54,null],[11,"rust_type_to_dbtype","","",54,null],[11,"fmt","rustorm::platform","",53,null],[11,"description","","",53,null],[11,"cause","","",53,null],[11,"fmt","","",53,null],[11,"from","","",53,{"inputs":[{"name":"pgerror"}],"output":{"name":"self"}}],[11,"from","","",53,{"inputs":[{"name":"pgconnecterror"}],"output":{"name":"self"}}],[0,"table","rustorm","",null,null],[3,"Foreign","rustorm::table","",null,null],[12,"schema","","",55,null],[12,"table","","",55,null],[12,"column","","",55,null],[3,"Column","","",null,null],[12,"table","","",56,null],[12,"name","","",56,null],[12,"data_type","","the generic data type, ie: u32, f64, string",56,null],[12,"db_data_type","","the database data type of this column, ie: int, numeric, character varying",56,null],[12,"is_primary","","",56,null],[12,"is_unique","","",56,null],[12,"default","","",56,null],[12,"comment","","",56,null],[12,"not_null","","",56,null],[12,"foreign","","",56,null],[12,"is_inherited","","determines if the column is inherited from the parent table",56,null],[3,"RefTable","","all referenced table used in context",null,null],[12,"table","","the table being referred",57,null],[12,"is_ext","","",57,null],[12,"is_has_one","","",57,null],[12,"is_has_many","","",57,null],[12,"is_direct","","",57,null],[3,"Table","","",null,null],[12,"schema","","which schema this belongs",58,null],[12,"name","","the table name",58,null],[12,"parent_table","","the parent table of this table when inheriting (&gt;= postgresql 9.3)\n[FIXME] need to tell which schema this parent table belongs\nthere might be same table in different schemas",58,null],[12,"sub_table","","what are the other table that inherits this\n[FIXME] need to tell which schema this parent table belongs\nthere might be same table in different schemas",58,null],[12,"comment","","comment of this table",58,null],[12,"columns","","columns of this table",58,null],[12,"is_view","","views can also be generated",58,null],[8,"IsTable","","trait for table definition",null,null],[10,"table","","",59,{"inputs":[],"output":{"name":"table"}}],[11,"eq","","",55,null],[11,"ne","","",55,null],[11,"clone","","",55,null],[11,"fmt","","",55,null],[11,"from_str","","",55,{"inputs":[{"name":"str"},{"name":"str"}],"output":{"name":"self"}}],[11,"complete_table_name","","",55,null],[11,"clone","","",56,null],[11,"fmt","","",56,null],[11,"nullable","","",56,null],[11,"complete_name","","",56,null],[11,"corrected_name","","some column names may be a rust reserve keyword, so have to correct them",56,null],[11,"displayname","","",56,null],[11,"condense_name","","shorten, compress the name based on the table it points to\nparent_organization_id becomes parent",56,null],[11,"fmt","","",56,null],[11,"eq","","",56,null],[11,"ne","","",56,null],[11,"member_name","","return the appropriate member name of this reference\nwhen used with the table in context\nwill have to use another name if the comed up name\nalready in the column names\n1. the concise name of the referred/referrring table\n2. the name of the referred/referring table\n3. the appended column_name and the table name\n4. the table_name appended with HasMany, or HasOne\n1:1, 1:M, M:M\n11, 1m mm",57,null],[11,"fmt","","",58,null],[11,"clone","","",58,null],[11,"default","","",58,{"inputs":[],"output":{"name":"table"}}],[11,"fmt","","",58,null],[11,"eq","","",58,null],[11,"ne","","",58,null],[11,"with_name","","create table with name",58,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"complete_name","","return the long name of the table using schema.table_name",58,null],[11,"struct_name","","capitalize the first later, if there is underscore remove it then capitalize the next letter",58,null],[11,"displayname","","get the display name of this table\nproduct_availability -&gt; Product Availability",58,null],[11,"condensed_displayname","","get a shorter display name of a certain table\nwhen being refered to this table\nexample product.product_availability -&gt; Availability\nuser.user_info -&gt; Info",58,null],[11,"condensed_member_name","","get a condensed name of this table when used in contex with another table",58,null],[11,"has_column_name","","determine if this table has a colum named",58,null],[11,"get_column","","return the column of this table with the name",58,null],[11,"primary_columns","","return all the primary columns of this table",58,null],[11,"non_nullable_columns","","",58,null],[11,"uninherited_columns","","return all the columns of this table excluding the inherited columns",58,null],[11,"inherited_columns","","return all the inherited columns",58,null],[11,"is_primary","","check to see if the column is a primary or not\nthe Column.is_primary property is not reliable since it also list down the foreign key\nwhich makes it 2 entries in the table",58,null],[11,"are_primary_columns","","return true when all columns are primary columns\nfalse if at least 1 is not a primary column",58,null],[11,"unique_columns","","return all the unique keys of this table",58,null],[11,"foreign_columns","","",58,null],[11,"get_table","","return the first match of table name regardless of which schema it belongs to.\nget the table definition using the table name from an array of table object\n[FIXME] Needs to have a more elegant solution by using HashMap",58,null],[11,"referred_tables","","get all the tables that is referred by this table\nget has_one",58,null],[11,"referring_tables","","has_many_direct\nget all other tables that is refering to this table\nwhen any column of a table refers to this table\nget_has_many",58,null],[11,"get_all_applicable_reference","","all the referenced table of this table, this is used in building the structs as stubs or final model definitions\nit does not include the parent is this table is just an extension to it\nwhen a linker table, no applicable referenced is returned\nparent of extension tables are not returned",58,null],[11,"is_linker_table","","determine if this table is a linker table\nFIXME: make sure that there are 2 different tables referred to it",58,null],[11,"is_owned_or_semi_owned","","",58,null],[11,"indirect_referring_tables","","has many indirect\nwhen there is a linker table, bypass the 1:1 relation to the linker table\nthen create a 1:M relation to the other linked table\nAlgorithmn: determine whether a table is a linker then get the other linked table\n       *get all the referring table\n       *for each table that refer to this table\n       *if there are only 2 columns and is both primary\n           and foreign key at the same time\n        and 1 of which refer to the primary column of this table\n    * then the other table that is refered is the indirect referring table\nreturns the table that is indirectly referring to this table and its linker table",58,null],[11,"direct_tables","","",58,null],[11,"indirect_tables","","",58,null],[11,"extension_tables","","get referring tables, and check if primary columns of these referring table\nis the same set of the primary columns of this table\nit is just an extension table\n[FIXED]~~FIXME:~~ 2 primary 1 foreign should not be included as extension table\ncase for photo_sizes",58,null],[11,"is_extension_of","","determines if this table is just an extension of the table specified\nextension tables need not to contain a reference of their parent table",58,null],[11,"get_foreign_columns_to_table","","returns the columns of these table that is a foreign columns to the foreign table",58,null],[0,"writer","rustorm","",null,null],[3,"SqlFrag","rustorm::writer","sql fragment\nuse this for writing SQL statements",null,null],[12,"sql","","",60,null],[12,"params","","",60,null],[12,"sql_options","","",60,null],[12,"build_mode","","",60,null],[11,"fmt","","",60,null],[11,"new","","",60,{"inputs":[{"name":"vec"},{"name":"buildmode"}],"output":{"name":"self"}}],[11,"append","","",60,null],[11,"appendln","","",60,null],[11,"tab","","",60,null],[11,"tabs","","",60,null],[11,"ln","","",60,null],[11,"ln_tab","","",60,null],[11,"ln_tabs","","",60,null],[11,"comma","","",60,null],[11,"sp","","",60,null],[11,"spaces","","",60,null],[11,"left_river","","write the string, aligning to the left side of the middle space (river)",60,null],[11,"right_river","","write the string, aligning to the right side of the middle space (river), leaving the left with empty string",60,null],[11,"commasp","","",60,null],[11,"comment","","",60,null],[11,"parameter","","append parameter including the needed sql keywords",60,null],[0,"config","rustorm","",null,null],[3,"DbConfig","rustorm::config","",null,null],[12,"platform","","postgres, sqlite, mysql\nsome fields are optional since sqlite is not applicable for those",61,null],[12,"username","","",61,null],[12,"password","","",61,null],[12,"host","","localhost",61,null],[12,"port","","5432",61,null],[12,"database","","",61,null],[12,"ssl","","",61,null],[11,"fmt","","",61,null],[11,"eq","","",61,null],[11,"ne","","",61,null],[11,"clone","","",61,null],[11,"from_url","","TODO: get rid of the hacky way parsing database url\nhttps://github.com/servo/rust-url/issues/40",61,{"inputs":[{"name":"str"}],"output":{"name":"option"}}],[11,"get_url","","",61,null],[0,"pool","rustorm","",null,null],[4,"Platform","rustorm::pool","the sql builder for each of the database platform",null,null],[13,"Postgres","","",62,null],[13,"Oracle","","",62,null],[4,"ManagedPool","","Postgres, Sqlite uses r2d2 connection manager,\nMysql has its own connection pooling",null,null],[13,"Postgres","","",63,null],[13,"Oracle","","",63,null],[11,"as_ref","","",62,null],[11,"as_ddl","","",62,null],[11,"as_dev","","",62,null],[11,"deref","","",62,null],[11,"init","","initialize the pool",63,{"inputs":[{"name":"str"},{"name":"usize"}],"output":{"name":"result"}}],[11,"connect","","a conection is created here",63,null],[11,"to_column_name","rustorm::table","",56,null],[11,"to_table_name","","contain the columns for later use when renaming is necessary",58,null],[11,"to_source_field","rustorm::query::source","",37,null],[11,"to_source_field","rustorm::table","",58,null]],"paths":[[3,"Range"],[3,"Query"],[4,"SqlType"],[4,"Error"],[3,"ColumnName"],[8,"ToColumnName"],[3,"TableName"],[8,"ToTableName"],[3,"Condition"],[3,"Filter"],[4,"Connector"],[4,"Equality"],[8,"HasEquality"],[3,"QueryBuilder"],[3,"Function"],[3,"Join"],[4,"JoinType"],[4,"Modifier"],[8,"ToJoin"],[4,"Operand"],[8,"ToOperand"],[3,"String"],[4,"Json"],[3,"Vec"],[3,"Uuid"],[3,"DateTime"],[3,"NaiveDate"],[3,"NaiveTime"],[3,"NaiveDateTime"],[3,"Order"],[4,"Direction"],[4,"NullsWhere"],[8,"ToOrder"],[8,"HasDirection"],[3,"Field"],[8,"ToField"],[8,"Rename"],[3,"SourceField"],[4,"QuerySource"],[8,"ToSourceField"],[3,"DaoResult"],[4,"Type"],[4,"Value"],[8,"IsDao"],[8,"ToCompact"],[8,"ToValue"],[8,"FromValue"],[4,"SqlOption"],[4,"BuildMode"],[4,"DbError"],[8,"Database"],[8,"DatabaseDDL"],[8,"DatabaseDev"],[4,"PlatformError"],[3,"Postgres"],[3,"Foreign"],[3,"Column"],[3,"RefTable"],[3,"Table"],[8,"IsTable"],[3,"SqlFrag"],[3,"DbConfig"],[4,"Platform"],[4,"ManagedPool"]]};
initSearch(searchIndex);
